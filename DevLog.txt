3:3 
almost finished the worst code I have ever written in my life for the neural network. It need MASSIVE CLEANING

Go fix te Synapses: Currently OTHER is not pointing to the corret place




3/7:

Success, Everything seems to be working perfectly, There are some minor snags that need to be addressed such as data normalization. When the angle
The Cell is already facing is used as an input then the direction of every cell all lands on a single position due to that
data overpowering the other data in the network. Its good that I caught something like that this early because now I must
think about how I plan to set the inputs of the network up so that they are all in the same range.






















// Left overs..... Brain.h











/*
class Synapse{
    Neuron *Parent;
    Neuron *Child;
};

struct Neuron{
public:
    double Weight,
           Bias;

    Neuron():Bias(1){}

    vector<Synapse> Connections;
};


class Layer{
public:
    int Number_of_Neurons;
    vector<Neuron> Neurons;
};

class Brain{
public:
    int Number_of_layers;
    vector<Layer> Layers;
};*/


 


//



//  for(int NeuronCount = 0;NeuronCount < hidden; NeuronCount++)
//  {
//          for(int inputcount = 0; inputcount < Layers[0].Number_of_Neurons ; inputcount++)
//          {
//                 Synapse Syn =  Synapse(RANDOM(1), &Layers[1].Neurons[NeuronCount] );
//                  Syn.Other = &Layers[1].Neurons[NeuronCount];
//                 Layers[0].Neurons[inputcount].Synapses.push_back(Syn);
//          }
//  }
//
//
//  for(int NeuronCount = 0;NeuronCount < outputs; NeuronCount++)
//  {
//          for(int inputcount = 0; inputcount < Layers[2].Number_of_Neurons; inputcount++)
//          {
//                 Synapse Syn = Synapse(RANDOM(1), &Layers[2].Neurons[NeuronCount] );
//                 Syn.Other = &Layers[2].Neurons[NeuronCount];
//                 Layers[1].Neurons[inputcount].Synapses.push_back(Syn);
//          }
//  }
//

main.cpp




   // for(int LayerCount = 0;LayerCount < (Number_of_Layers - 1); LayerCount++){
   //     for(int NeuronCount = 0; NeuronCount < Layers[LayerCount].Number_of_Neurons;NeuronCount++ ){
   //          
   //     }
   // }





//???   LAST CELL DOES NOT EFFECT ALL OTHER, THE FIRST PROCESSED EFFECTS ALL AND CREATES A HIERACHY









/*
void main(){
    
    vector<Neuron> Brain ;
    
    Brain.resize(NUBER_OF_NEURONS);

    for(Neuron &n: Brain){
        n.Synapses.resize(NUBER_OF_NEURONS);
        n.Voltage = RANDOM(2) - 1;
       Print(n.Voltage);
    }
    Print(Brain.size());

    for(int count = Brain.size(); count > 0;count--)
    {
        Print(Brain[count - 1].Voltage);
    }

   // Print(Brain.back().Voltage);
    system("PAUSE");
}*/




CELL.CPP








// FORCE.X = FORCE_APPLIED * COS(ANGLE)
// FORCE.Y = FORCE_APPLIED * SIN(ANGLE)
// acceleration = netForce / mass
/// Acceleration = change in Velocity / change in time
/// Velocity = Velocity + Acceleration
// Acceleration = Force / Mass

//=============================================================================================================================================================
//                                                                                                                                                             
//=============================================================================================================================================================


//  Child.Delta_Distance = Child.Distance - Get_Distance(*Child.second, Parent); // Prob does not need to exist but may be useful to calculate yet not store


// (EX:)    tf = 2.47seconds     Acceleration = 46.1(m/s) - 18.5(m/s)  / 2.47(seconds) - 0(seconds) = 11.17(m/s^2)
//           ti = 0                                                                                                                  
//                                                                                                                       
//      Change in Velocity = Final Velocity - Initial Velocity                                                                                                 
//      Change in Time     = Final Time - Initial Time            
//                                                                                                                        
//      Acceleration       = Change in time / Change in Velocity                                                                                               
//                                                                                                                        
//                                                                                                                        
//                                                                                                                        
//       1 Newton = 1kg - (m/s^2)                                                                                                                 
//       <-2N-- + --7N-> = --5N->                                                                                                             
//                                                                                                                        
// (EX:) F            = 10N                                                                                                                       
//       mass         = 2kg                                                                                                                 
//       Acceleration = 10N / 2kg = 5(m/s^2)
//                                                                                                                        
//     Origin == Parent
//     Bob = Child
//     Direction =   Bob - Origin           
//   Current length = disance from Parent to Child.
//    Rest Length = Child.Distance
//    K = .1
//    displacement  Current length - Rest Length                                                                                                                  
//                                                                                                                        
//                                                                                                                        
////   hooks law 
////    -K is constant
// Displacement = Change in shape
////    Force = -K * Displacement







//============ MAKE A SPHERE WITH EVERY EDGE CONNECTED TO EVERY OTHER CELL
//
//FOR_LOOP(cellcount, numcells){                                                // FOR EACH CELL.....
//    int e = 0;
//     for(int edgecount = 0; edgecount  <  numcells;edgecount++ ){                                            // MAKE EDGES CONNECTING THE OTHER CELLS
//         if(edgecount != cellcount){
//                   cells[cellcount].edges.push_back(MakeEdge(&cells[cellcount], cells[edgecount], RANDOM(1)));  
//                   e++;
//     }
// }
//}





    /*  MAKE RANDOM CONNECTIONS
    int e = rand()%(numcells - 1);
FOR_LOOP(cellcount, e){
    FOR_LOOP(edgecount,e){
        cells[cellcount].edges.push_back(MakeEdge(&cells[rand()%numcells], cells[rand()%numcells], RANDOM(1)));
                cells[cellcount].edges.push_back(MakeEdge(&cells[rand()%numcells], cells[rand()%numcells], RANDOM(1)));
                        cells[cellcount].edges.push_back(MakeEdge(&cells[rand()%numcells], cells[rand()%numcells], RANDOM(1)));
    }
}*/




//FOR_LOOP(cellcount, numcells - 1){                                                // FOR EACH CELL.....
//    int a = cellcount,b =0;
//    if(a == 0) b = numcells-1;
//    if(a == numcells-1) b = 0;
//       cells[cellcount].edges.push_back(MakeEdge(&cells[a], cells[b], RANDOM(1)));  
//       cells[cellcount].edges.push_back(MakeEdge(&cells[b], cells[a], RANDOM(1)));  
//}
//







//for(int cellcount = numcells - 1;cellcount > 1;cellcount--){
//      cells[cellcount].edges.push_back(MakeEdge(&cells[cellcount], cells[cellcount-1], RANDOM(1)));  
//
//}
//
 //FOR_LOOP(cellcount, numcells){                                                // FOR EACH CELL.....
 //    int e = 0;
 //     for(int edgecount = 0; edgecount  <  numcells;edgecount++ ){                                            // MAKE EDGES CONNECTING THE OTHER CELLS
 //         if(edgecount != cellcount){
 //                   cells[cellcount].edges.push_back(MakeEdge(&cells[cellcount], cells[edgecount], RANDOM(1)));  
 //                   e++;
 //     }
 // }
 //}


 //

     //   FOR_LOOP(edgecount, numcells){                                            // MAKE EDGES CONNECTING THE OTHER CELLS
          
      //                 cells.back().edges[numcells] = MakeEdge(cells[numcells], cells[edgecount], RANDOM(1));  
   //           }








   
 //
 //for(Neuron &H: Layers[1].Neurons){
 //    for(Neuron &I: Layers[0].Neurons){
 //         Synapse *Syn =  new Synapse(RANDOM(1), I);  
 //        // Syn.Other = &I; // SHOULD NOT NEED THIS AS IT SHOULD BE ASSIGNEDD IN THE ABOVE
 //         Layers[1].Neurons.Synapses.push_back(Syn);
 //    }
 //}
 //
 //  // Layers[1].Neurons[I].Synapses.reserve(Layers[1].Number_of_Neurons);
 //FOR_LOOP(H, Layers[1].Number_of_Neurons){
 //     FOR_LOOP(I , Layers[0].Number_of_Neurons){
 //         Synapse *Syn = new Synapse(RANDOM(1), Layers[0].Neurons[I]);//MakeSynapse(RANDOM(1), &Layers[0].Neurons[I]);  
 //         Layers[1].Neurons[H].Synapses->push_back(*Syn);   // Synapses.push_back(&Syn);
 //     }
 // }
 //
 //
 //FOR_LOOP(O, Layers[2].Number_of_Neurons){
 //     FOR_LOOP(H , Layers[1].Number_of_Neurons){
 //         Synapse *Syn = new Synapse(RANDOM(1), Layers[1].Neurons[H]);//Synapse Syn = MakeSynapse(RANDOM(1),  &Layers[1].Neurons[H]);  
 //         Layers[2].Neurons[O].Synapses->push_back(*Syn);   // Synapses.push_back(&Syn);
 //     }
 // }
 //


//  for(Neuron &O: Layers[2].Neurons){
//       for(Neuron &H: Layers[1].Neurons){
//            Synapse *Syn =  new Synapse(RANDOM(1), H);  
//           // Syn.Other = &H; // SHOULD NOT NEED THIS AS IT SHOULD BE ASSIGNEDD IN THE ABOVE
//            Layers[2].Neurons.Synapses.push_back(&Syn);
//       }
//  }
//
//







//
//
// for(Neuron &H: Layers[1].Neurons){
//     for(Neuron &I: Layers[0].Neurons){
//          H.Synapses.push_back(MakeSynapse(RANDOM(1), &H, &I));   // Synapses.push_back(&Syn);
//     }
// }
//
// int Hcount=0,
//     Ocount=0;
 // for(Neuron &O: Layers[2].Neurons){
 //     Hcount = 0;
 //     for(Neuron &H: Layers[1].Neurons){
 //          O.Synapses.push_back(MakeSynapse(RANDOM(1), &O, &Layers[1].Neurons[Hcount]));   // Synapses.push_back(&Syn);
 //          Hcount++;
 //     }
 //     Ocount++;
 // }
 //

 // FOR_LOOP(Hcount, Layers[1].Number_of_Neurons){
 //     FOR_LOOP(Icount, Layers[0].Number_of_Neurons){
 //          Layers[1].Neurons[Hcount].Synapses.push_back(
 //              MakeSynapse(RANDOM(1), &Layers[1].Neurons[Hcount], &Layers[0].Neurons[Icount]));    
 //     }
 // }
 // 
 // FOR_LOOP(Ocount, Layers[2].Number_of_Neurons){
 //     FOR_LOOP(Hcount, Layers[1].Number_of_Neurons){
 //          Layers[2].Neurons[Ocount].Synapses.push_back(
 //              MakeSynapse(RANDOM(1), &Layers[2].Neurons[Ocount], &Layers[1].Neurons[Hcount]));    
 //     }
 // }
 //
